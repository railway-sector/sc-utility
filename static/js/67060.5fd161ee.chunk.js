"use strict";(self.webpackChunksc_utility=self.webpackChunksc_utility||[]).push([[67060],{63928:(e,t,i)=>{i.d(t,{W:()=>a});var r=i(45463),n=i(48168);class a extends r.i{intersect(e,t,i,r,a,s){return(0,n.Uy)(e,i,r,a,void 0,s)}intersectDraped(e,t,i,r){return(0,n.gz)(i[0],i[1],e,r)}}},86401:(e,t,i)=>{i.d(t,{Ci:()=>n,KL:()=>o,dB:()=>s,l5:()=>a,wB:()=>c});var r=i(48549);const n=(0,r.BP)().vec3f("position").freeze(),a=(0,r.BP)().vec3f("position").vec2f16("uv0").freeze(),s=(0,r.BP)().vec3f("position").vec4u8("color").freeze(),o=(0,r.BP)().vec3f("position").vec2f("uv0").freeze(),c=(0,r.BP)().vec3f("position").vec2f("uv0").vec4u8("olidColor").freeze()},88849:(e,t,i)=>{i.d(t,{L:()=>R,b:()=>F});var r,n,a,s,o,c,l,p,d,h,v,u,m,f,g,S,P=i(57528),y=i(99443),z=i(26917),w=i(3838),x=i(87236),_=i(17698),b=i(94192),C=i(80883),W=i(20179),T=i(3799),k=i(28450),V=i(51596),D=i(58350),O=i(23148),A=i(86955),L=i(23687),M=i(70367),N=i(91911),j=i(2687);function F(e){const t=new j.N5,{space:i,anchor:F,hasTip:R,hasScreenSizePerspective:H}=e,E=2===i,I=1===i;t.include(w.s,e),t.include(_.r,e),t.include(b.Z,e);const{vertex:B,fragment:U,varyings:q}=t;(0,T.NB)(B,e),t.attributes.add("position","vec3"),t.attributes.add("previousDelta","vec4"),t.attributes.add("uv0","vec2"),q.add("vColor","vec4"),q.add("vpos","vec3",{invariant:!0}),q.add("vUV","vec2"),q.add("vSize","float"),R&&q.add("vLineWidth","float"),B.uniforms.add(new k.E("nearFar",e=>{let{camera:t}=e;return t.nearFar}),new V.I("viewport",e=>{let{camera:t}=e;return t.fullViewport})).code.add((0,A.H)(r||(r=(0,P.A)(["vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}"])))),B.code.add((0,A.H)(n||(n=(0,P.A)(["void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}"])))),E?(t.attributes.add("normal","vec3"),(0,T.S7)(B),B.constants.add("tiltThreshold","float",.7),B.code.add((0,A.H)(a||(a=(0,P.A)(["vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}"]))))):B.code.add((0,A.H)(s||(s=(0,P.A)(["vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}"]))));const K=E?"vec3":"vec2";return B.code.add((0,A.H)(o||(o=(0,P.A)(["\n      "," normalizedSegment("," pos, "," prev) {\n        "," segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ",";\n      }\n\n      "," displace("," pos, "," prev, float displacementLen) {\n        "," segment = normalizedSegment(pos, prev);\n\n        "," displacementDirU = perpendicular(segment);\n        "," displacementDirV = segment;\n\n        ","\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    "])),K,K,K,K,E?"vec3(0.0, 0.0, 0.0)":"vec2(0.0, 0.0)",K,K,K,K,K,K,1===F?"pos -= 0.5 * displacementLen * displacementDirV;":"")),I&&(B.uniforms.add(new L.F("inverseProjectionMatrix",e=>{let{camera:t}=e;return t.inverseProjectionMatrix})),B.code.add((0,A.H)(c||(c=(0,P.A)(["vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}"])))),B.code.add((0,A.H)(l||(l=(0,P.A)(["bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}"])))),B.uniforms.add(new O.U("perScreenPixelRatio",e=>{let{camera:t}=e;return t.perScreenPixelRatio})),B.code.add((0,A.H)(p||(p=(0,P.A)(["\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ",";\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  "])),(0,A.If)(e.hasCap,"if(prev.z > posLeft.z) {\n                vec2 diff = posLeft.xy - posRight.xy;\n                planeOrigin.xy += perpendicular(diff) / 2.0;\n             }")))),(0,T.Nz)(B),t.include(W.F),B.main.add((0,A.H)(d||(d=(0,P.A)(["\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(position + previousDelta.xyz * previousDelta.w, 1.0);\n\n      float lineWidth = getLineWidth(",");\n      float screenMarkerSize = getScreenMarkerSize(lineWidth);\n\n      clip(pos, prev);\n\n      ","\n      forwardViewPosDepth(pos.xyz);\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ","\n      ","\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }"])),(0,A.If)(H,"pos.xyz"),E?(0,A.H)(h||(h=(0,P.A)(["","\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos.xyz));\n            vec4 displacedPosScreen = projectAndScale(pos);"])),(0,A.If)(e.hideOnShortSegments,(0,A.H)(v||(v=(0,P.A)(["\n                if (areWorldMarkersHidden(pos.xyz, prev.xyz)) {\n                  // Project out of clip space\n                  gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                  return;\n                }"]))))):(0,A.H)(u||(u=(0,P.A)(["\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ",""])),(0,A.If)(I,(0,A.H)(m||(m=(0,P.A)(["\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);"]))))),(0,A.If)(!E,"vUV = noPerspectiveWrite(vUV, displacedPosScreen.w);"),(0,A.If)(R,"vLineWidth = noPerspectiveWrite(lineWidth, displacedPosScreen.w);"))),U.include(z.HQ,e),t.include(N.z,e),U.include(C.a),U.uniforms.add(new D.E("intrinsicColor",e=>{let{color:t}=e;return t}),new M.N("tex",e=>{let{markerTexture:t}=e;return t})).constants.add("texelSize","float",1/y.vO).code.add((0,A.H)(f||(f=(0,P.A)(["float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = texture(tex, samplePos).r;\nfloat pixelDistance = sdf * vSize;\npixelDistance -= 0.5;\nreturn clamp(0.5 - pixelDistance, 0.0, 1.0);\n}"])))),R&&(t.include(W.m),U.constants.add("relativeMarkerSize","float",y.Cz/y.vO).constants.add("relativeTipLineWidth","float",y.DZ).code.add((0,A.H)(g||(g=(0,P.A)(["\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * noPerspectiveRead(vLineWidth));\n\n      ","\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  "])),(0,A.If)(E,"halfTipLineWidth *= fwidth(samplePos.y);")))),t.include(x.Q,e),t.include(W.m),U.main.add((0,A.H)(S||(S=(0,P.A)(["\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Cancel out perspective correct interpolation if in screen space or draped\n    vec2 samplePos = ",";\n    finalColor.a *= ",";\n    outputColorHighlightOID(finalColor, vpos, finalColor.rgb);"])),(0,A.If)(!E,"noPerspectiveRead(vUV)","vUV"),R?"max(markerAlpha(samplePos), tipAlpha(samplePos))":"markerAlpha(samplePos)")),t}const R=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}))},97349:(e,t,i)=>{i.d(t,{i:()=>b});var r=i(20664),n=i(9392),a=i(62984),s=i(34981),o=i(59696),c=i(45463),l=i(93684),p=i(52757),d=i(48549),h=i(16506),v=i(59246),u=i(60322),m=i(96643),f=i(88849),g=i(57162);class S extends v.w{constructor(e,t){super(e,t,new h.$(f.L,()=>i.e(66419).then(i.bind(i,66419))),P(t).locations)}_makePipelineState(e,t){const{output:i,oitPass:r,space:n,hasOccludees:a}=e;return(0,g.Ey)({blending:(0,s.RN)(i)?(0,u.Yf)(r):null,depthTest:0===n?null:{func:(0,u.K_)(r)},depthWrite:(0,u.z5)(e),drawBuffers:(0,v.L)(i,(0,u.m6)(r,i)),colorWrite:g.kn,stencilWrite:a?m.v0:null,stencilTest:a?t?m.a9:m.qh:null,polygonOffset:{factor:0,units:-10}})}initializePipeline(e){return e.occluder?(this._occluderPipelineTransparent=(0,g.Ey)({blending:g.T8,depthTest:m.sf,depthWrite:null,colorWrite:g.kn,stencilWrite:null,stencilTest:m.mK}),this._occluderPipelineOpaque=(0,g.Ey)({blending:g.T8,depthTest:m.sf,depthWrite:null,colorWrite:g.kn,stencilWrite:m.r8,stencilTest:m.I$}),this._occluderPipelineMaskWrite=(0,g.Ey)({blending:null,depthTest:m.m,depthWrite:null,colorWrite:null,stencilWrite:m.v0,stencilTest:m.a9})):this._occluderPipelineTransparent=this._occluderPipelineOpaque=this._occluderPipelineMaskWrite=null,this._occludeePipelineState=this._makePipelineState(e,!0),this._makePipelineState(e,!1)}getPipeline(e,t){var i,r,n;return e?this._occludeePipelineState:11===t?null!==(i=this._occluderPipelineTransparent)&&void 0!==i?i:super.getPipeline():10===t?null!==(r=this._occluderPipelineOpaque)&&void 0!==r?r:super.getPipeline():null!==(n=this._occluderPipelineMaskWrite)&&void 0!==n?n:super.getPipeline()}}function P(e){const t=(0,d.BP)().vec3f("position").vec4f16("previousDelta").vec2f16("uv0");return e.hasVVColor?t.f32("colorFeatureAttribute"):t.vec4u8("color",{glNormalized:!0}),e.hasVVOpacity&&t.f32("opacityFeatureAttribute"),e.hasVVSize?t.f32("sizeFeatureAttribute"):t.f16("size"),e.worldSpace&&t.vec3f16("normal"),t.freeze()}var y=i(6326),z=i(6485),w=i(92656);class x extends w.E{constructor(e){super(),this.spherical=e,this.space=1,this.anchor=0,this.occluder=!1,this.writeDepth=!1,this.hideOnShortSegments=!1,this.hasCap=!1,this.hasTip=!1,this.hasVVSize=!1,this.hasVVColor=!1,this.hasVVOpacity=!1,this.hasOccludees=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.hasScreenSizePerspective=!1,this.textureCoordinateType=0,this.emissionSource=0,this.discardInvisibleFragments=!0,this.occlusionPass=!1,this.hasVVInstancing=!1,this.hasSliceTranslatedView=!0,this.olidColorInstanced=!1,this.overlayEnabled=!1,this.snowCover=!1}get draped(){return 0===this.space}get worldSpace(){return 2===this.space}}(0,y.Cg)([(0,z.W)({count:3})],x.prototype,"space",void 0),(0,y.Cg)([(0,z.W)({count:2})],x.prototype,"anchor",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"occluder",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"writeDepth",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hideOnShortSegments",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasCap",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasTip",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasVVSize",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasVVColor",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasVVOpacity",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasOccludees",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"terrainDepthTest",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"cullAboveTerrain",void 0),(0,y.Cg)([(0,z.W)()],x.prototype,"hasScreenSizePerspective",void 0);var _=i(75569);class b extends c.i{constructor(e,t){super(e,W),this.produces=new Map([[2,e=>9===e||(0,s.RN)(e)&&8===this.parameters.renderOccluded],[3,e=>(0,s.eh)(e)],[10,e=>(0,s.T2)(e)&&8===this.parameters.renderOccluded],[11,e=>(0,s.T2)(e)&&8===this.parameters.renderOccluded],[4,e=>(0,s.RN)(e)&&this.parameters.writeDepth],[8,e=>(0,s.RN)(e)&&!this.parameters.writeDepth],[18,e=>(0,s.RN)(e)||9===e]]),this.intersectDraped=void 0,this._configuration=new x(t)}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.space=18===t.slot?0:this.parameters.worldSpace?2:1,this._configuration.hideOnShortSegments=this.parameters.hideOnShortSegments,this._configuration.hasCap=0!==this.parameters.cap,this._configuration.anchor=this.parameters.anchor,this._configuration.hasTip=this.parameters.hasTip,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=t.hasOccludees,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasVVSize=this.parameters.hasVVSize,this._configuration.hasVVColor=this.parameters.hasVVColor,this._configuration.hasVVOpacity=this.parameters.hasVVOpacity,this._configuration.occluder=8===this.parameters.renderOccluded,this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest&&(0,s.RN)(e),this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration.hasScreenSizePerspective=null!=this.parameters.screenSizePerspective,this._configuration}get visible(){return this.parameters.color[3]>=_.Q}intersect(){}createBufferWriter(){return new T(P(this.parameters),this.parameters)}createGLMaterial(e){return new C(e)}}class C extends o.A{dispose(){var e;super.dispose(),null!==(e=this._markerTextures)&&void 0!==e&&e.release(this._markerPrimitive),this._markerPrimitive=null}beginSlot(e){const t=this._material.parameters.markerPrimitive;return t!==this._markerPrimitive&&(this._material.setParameters({markerTexture:this._markerTextures.swap(t,this._markerPrimitive)}),this._markerPrimitive=t),this.getTechnique(S,e)}}class W extends l.S{constructor(){super(...arguments),this.width=0,this.color=[1,1,1,1],this.markerPrimitive="arrow",this.placement="end",this.cap=0,this.anchor=0,this.hasTip=!1,this.worldSpace=!1,this.hideOnShortSegments=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.stipplePattern=null,this.markerTexture=null}}class T{constructor(e,t){this.layout=e,this._parameters=t}elementCount(){return"begin-end"===this._parameters.placement?12:6}write(e,t,i,n,s,o){const c=i.get("position").data,l=c.length/3;let d=[1,0,0];const h=i.get("normal");this._parameters.worldSpace&&null!=h&&(d=h.data);let v=1,u=0;this._parameters.vvSize?u=i.get("sizeFeatureAttribute").data[0]:i.has("size")&&(v=i.get("size").data[0]);let m=[1,1,1,1],f=0;this._parameters.vvColor?f=i.get("colorFeatureAttribute").data[0]:i.has("color")&&(m=i.get("color").data);let g=0;this._parameters.vvOpacity&&(g=i.get("opacityFeatureAttribute").data[0]);const S=new Float32Array(s.buffer),P=(0,a.Bg)(s.buffer),y=new Uint8Array(s.buffer);let z=o*(this.layout.stride/4);const w=S.BYTES_PER_ELEMENT/P.BYTES_PER_ELEMENT,x=4/w,_=(e,t,i,r)=>{S[z++]=e[0],S[z++]=e[1],S[z++]=e[2],(0,p.Wu)(t,e,P,z*w),z+=x;let n=z*w;if(P[n++]=i[0],P[n++]=i[1],z=Math.ceil(n/w),this._parameters.vvColor)S[z++]=f;else{const e=Math.min(4*r,m.length-4),t=4*z++;y[t]=255*m[e],y[t+1]=255*m[e+1],y[t+2]=255*m[e+2],y[t+3]=255*m[e+3]}this._parameters.vvOpacity&&(S[z++]=g),n=z*w,this._parameters.vvSize?(S[z++]=u,n+=2):P[n++]=v,this._parameters.worldSpace&&(P[n++]=d[0],P[n++]=d[1],P[n++]=d[2]),z=Math.ceil(n/w)},b=(t,i)=>{const n=(0,r.j)(k,c[3*t],c[3*t+1],c[3*t+2]),a=V;let s=t+i;do{(0,r.j)(a,c[3*s],c[3*s+1],c[3*s+2]),s+=i}while((0,r.G)(n,a)&&s>=0&&s<l);e&&((0,r.t)(n,n,e),(0,r.t)(a,a,e)),_(n,a,[-1,-1],t),_(n,a,[1,-1],t),_(n,a,[1,1],t),_(n,a,[-1,-1],t),_(n,a,[1,1],t),_(n,a,[-1,1],t)},C=this._parameters.placement;return"begin"!==C&&"begin-end"!==C||b(0,1),"end"!==C&&"begin-end"!==C||b(l-1,-1),null}}const k=(0,n.vt)(),V=(0,n.vt)()}}]);
//# sourceMappingURL=67060.5fd161ee.chunk.js.map