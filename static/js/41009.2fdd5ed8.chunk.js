"use strict";(self.webpackChunksc_utility=self.webpackChunksc_utility||[]).push([[41009],{60561:(e,t,r)=>{r.d(t,{i:()=>I});var n=r(20664),i=r(9392),a=r(62984),s=r(48549),o=r(34981),c=r(59696),l=r(45463),p=r(77730),d=r(66470),h=r(93684),v=r(52757),u=r(16506),m=r(59246),f=r(60322),S=r(96643),T=r(88849),P=r(50125),g=r(57162);class A extends m.w{constructor(e,t){super(e,t,new u.$(T.L,()=>r.e(66419).then(r.bind(r,66419))),O)}_makePipelineState(e,t){const{output:r,oitPass:n,space:i,hasOccludees:a}=e;return(0,g.Ey)({blending:(0,o.RN)(r)?(0,f.Yf)(n):null,depthTest:i===P.lM.Draped?null:{func:(0,f.K_)(n)},depthWrite:(0,f.z5)(e),drawBuffers:(0,m.L)(r,(0,f.m6)(n,r)),colorWrite:g.kn,stencilWrite:a?S.v0:null,stencilTest:a?t?S.a9:S.qh:null,polygonOffset:{factor:0,units:-10}})}initializePipeline(e){return e.occluder?(this._occluderPipelineTransparent=(0,g.Ey)({blending:g.T8,depthTest:S.sf,depthWrite:null,colorWrite:g.kn,stencilWrite:null,stencilTest:S.mK}),this._occluderPipelineOpaque=(0,g.Ey)({blending:g.T8,depthTest:S.sf,depthWrite:null,colorWrite:g.kn,stencilWrite:S.r8,stencilTest:S.I$}),this._occluderPipelineMaskWrite=(0,g.Ey)({blending:null,depthTest:S.m,depthWrite:null,colorWrite:null,stencilWrite:S.v0,stencilTest:S.a9})):this._occluderPipelineTransparent=this._occluderPipelineOpaque=this._occluderPipelineMaskWrite=null,this._occludeePipelineState=this._makePipelineState(e,!0),this._makePipelineState(e,!1)}getPipeline(e,t){var r,n,i;return e?this._occludeePipelineState:t===p.N.TRANSPARENT_OCCLUDER_MATERIAL?null!==(r=this._occluderPipelineTransparent)&&void 0!==r?r:super.getPipeline():t===p.N.OCCLUDER_MATERIAL?null!==(n=this._occluderPipelineOpaque)&&void 0!==n?n:super.getPipeline():null!==(i=this._occluderPipelineMaskWrite)&&void 0!==i?i:super.getPipeline()}}const O=new Map([[d.r.POSITION,0],[d.r.PREVIOUSDELTA,1],[d.r.UV0,2],[d.r.COLOR,3],[d.r.COLORFEATUREATTRIBUTE,3],[d.r.OPACITYFEATUREATTRIBUTE,4],[d.r.SIZE,5],[d.r.SIZEFEATUREATTRIBUTE,5],[d.r.NORMAL,6]]);var E=r(46259),_=r(75569);class I extends l.im{constructor(e){super(e,y),this._configuration=new P.Dt,this.vertexAttributeLocations=O,this.produces=new Map([[p.N.OPAQUE_MATERIAL,e=>e===o.V.Highlight||(0,o._o)(e)&&this.parameters.renderOccluded===l.m$.OccludeAndTransparentStencil],[p.N.OPAQUE_MATERIAL_WITHOUT_NORMALS,e=>(0,o.eh)(e)],[p.N.OCCLUDER_MATERIAL,e=>(0,o.aD)(e)&&this.parameters.renderOccluded===l.m$.OccludeAndTransparentStencil],[p.N.TRANSPARENT_OCCLUDER_MATERIAL,e=>(0,o.aD)(e)&&this.parameters.renderOccluded===l.m$.OccludeAndTransparentStencil],[p.N.TRANSPARENT_MATERIAL,e=>(0,o._o)(e)&&this.parameters.writeDepth],[p.N.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>(0,o._o)(e)&&!this.parameters.writeDepth],[p.N.DRAPED_MATERIAL,e=>(0,o.RN)(e)||e===o.V.Highlight]]),this.intersectDraped=void 0,this._layout=this.createLayout()}getConfiguration(e,t){return super.getConfiguration(e,t,this._configuration),this._configuration.space=t.slot===p.N.DRAPED_MATERIAL?P.lM.Draped:this.parameters.worldSpace?P.lM.World:P.lM.Screen,this._configuration.hideOnShortSegments=this.parameters.hideOnShortSegments,this._configuration.hasCap=this.parameters.cap!==E.x.BUTT,this._configuration.anchor=this.parameters.anchor,this._configuration.hasTip=this.parameters.hasTip,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=t.hasOccludees,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.occluder=this.parameters.renderOccluded===l.m$.OccludeAndTransparentStencil,this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest&&(0,o.RN)(e),this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}get visible(){return this.parameters.color[3]>=_.Q}intersect(){}createLayout(){const e=(0,s.BP)().vec3f(d.r.POSITION).vec4f16(d.r.PREVIOUSDELTA).vec2f16(d.r.UV0);return this.parameters.vvColor?e.f32(d.r.COLORFEATUREATTRIBUTE):e.vec4u8(d.r.COLOR,{glNormalized:!0}),this.parameters.vvOpacity&&e.f32(d.r.OPACITYFEATUREATTRIBUTE),this.parameters.vvSize?e.f32(d.r.SIZEFEATUREATTRIBUTE):e.f16(d.r.SIZE),this.parameters.worldSpace&&e.vec3f16(d.r.NORMAL),e}createBufferWriter(){return new R(this._layout,this.parameters)}createGLMaterial(e){return new w(e)}}class w extends c.A{dispose(){super.dispose(),this._markerTextures.release(this._markerPrimitive),this._markerPrimitive=null}beginSlot(e){const t=this._material.parameters.markerPrimitive;return t!==this._markerPrimitive&&(this._material.setParameters({markerTexture:this._markerTextures.swap(t,this._markerPrimitive)}),this._markerPrimitive=t),this.getTechnique(A,e)}}class y extends h.S{constructor(){super(...arguments),this.width=0,this.color=[1,1,1,1],this.markerPrimitive="arrow",this.placement="end",this.cap=E.x.BUTT,this.anchor=P.kJ.Center,this.hasTip=!1,this.worldSpace=!1,this.hideOnShortSegments=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.markerTexture=null}}class R{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t}elementCount(){return"begin-end"===this._parameters.placement?12:6}write(e,t,r,i,s,o){const c=r.get(d.r.POSITION).data,l=c.length/3;let p=[1,0,0];const h=r.get(d.r.NORMAL);this._parameters.worldSpace&&null!=h&&(p=h.data);let u=1,m=0;this._parameters.vvSize?m=r.get(d.r.SIZEFEATUREATTRIBUTE).data[0]:r.has(d.r.SIZE)&&(u=r.get(d.r.SIZE).data[0]);let f=[1,1,1,1],S=0;this._parameters.vvColor?S=r.get(d.r.COLORFEATUREATTRIBUTE).data[0]:r.has(d.r.COLOR)&&(f=r.get(d.r.COLOR).data);let T=0;this._parameters.vvOpacity&&(T=r.get(d.r.OPACITYFEATUREATTRIBUTE).data[0]);const P=new Float32Array(s.buffer),g=(0,a.Bg)(s.buffer),A=new Uint8Array(s.buffer);let O=o*(this.vertexBufferLayout.stride/4);const E=P.BYTES_PER_ELEMENT/g.BYTES_PER_ELEMENT,_=4/E,I=(e,t,r,n)=>{P[O++]=e[0],P[O++]=e[1],P[O++]=e[2],(0,v.Wu)(t,e,g,O*E),O+=_;let i=O*E;if(g[i++]=r[0],g[i++]=r[1],O=Math.ceil(i/E),this._parameters.vvColor)P[O++]=S;else{const e=Math.min(4*n,f.length-4),t=4*O++;A[t]=255*f[e],A[t+1]=255*f[e+1],A[t+2]=255*f[e+2],A[t+3]=255*f[e+3]}this._parameters.vvOpacity&&(P[O++]=T),i=O*E,this._parameters.vvSize?(P[O++]=m,i+=2):g[i++]=u,this._parameters.worldSpace&&(g[i++]=p[0],g[i++]=p[1],g[i++]=p[2]),O=Math.ceil(i/E)};let w;var y;(y=w||(w={}))[y.ASCENDING=1]="ASCENDING",y[y.DESCENDING=-1]="DESCENDING";const R=(t,r)=>{const i=(0,n.i)(L,c[3*t],c[3*t+1],c[3*t+2]),a=N;let s=t+r;do{(0,n.i)(a,c[3*s],c[3*s+1],c[3*s+2]),s+=r}while((0,n.G)(i,a)&&s>=0&&s<l);e&&((0,n.t)(i,i,e),(0,n.t)(a,a,e)),I(i,a,[-1,-1],t),I(i,a,[1,-1],t),I(i,a,[1,1],t),I(i,a,[-1,-1],t),I(i,a,[1,1],t),I(i,a,[-1,1],t)},x=this._parameters.placement;return"begin"!==x&&"begin-end"!==x||R(0,w.ASCENDING),"end"!==x&&"begin-end"!==x||R(l-1,w.DESCENDING),null}}const L=(0,i.vt)(),N=(0,i.vt)()},86401:(e,t,r)=>{r.d(t,{Ci:()=>a,KL:()=>c,dB:()=>o,l5:()=>s,wB:()=>l});var n=r(48549),i=r(66470);const a=(0,n.BP)().vec3f(i.r.POSITION),s=(0,n.BP)().vec3f(i.r.POSITION).vec2f16(i.r.UV0),o=(0,n.BP)().vec3f(i.r.POSITION).vec4u8(i.r.COLOR),c=((0,n.BP)().vec3f(i.r.POSITION).vec2f16(i.r.UV0).vec4u8(i.r.OLIDCOLOR),(0,n.BP)().vec3f(i.r.POSITION).vec2f(i.r.UV0)),l=(0,n.BP)().vec3f(i.r.POSITION).vec2f(i.r.UV0).vec4u8(i.r.OLIDCOLOR)},88849:(e,t,r)=>{r.d(t,{L:()=>H,b:()=>B});var n,i,a,s,o,c,l,p,d,h,v,u,m,f,S,T,P=r(57528),g=r(99443),A=r(26917),O=r(3838),E=r(87236),_=r(17698),I=r(94192),w=r(80883),y=r(81449),R=r(3799),L=r(28450),N=r(51596),x=r(58350),z=r(23148),C=r(86955),D=r(23687),k=r(70367),U=r(66470),b=r(50125),M=r(91911),W=r(2687);function B(e){const t=new W.N5,{space:r,anchor:B,hasTip:H}=e,F=r===b.lM.World;t.include(O.s,e),t.include(_.r,e),t.include(I.Z,e);const{vertex:V,fragment:j,varyings:Z}=t;j.include(y.W),(0,R.NB)(V,e),t.attributes.add(U.r.POSITION,"vec3"),t.attributes.add(U.r.PREVIOUSDELTA,"vec4"),t.attributes.add(U.r.UV0,"vec2"),Z.add("vColor","vec4"),Z.add("vpos","vec3",{invariant:!0}),Z.add("vUV","vec2"),Z.add("vSize","float"),H&&Z.add("vLineWidth","float"),V.uniforms.add(new L.E("nearFar",e=>{let{camera:t}=e;return t.nearFar}),new N.I("viewport",e=>{let{camera:t}=e;return t.fullViewport})).code.add((0,C.H)(n||(n=(0,P.A)(["vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}"])))),V.code.add((0,C.H)(i||(i=(0,P.A)(["void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}"])))),F?(t.attributes.add(U.r.NORMAL,"vec3"),(0,R.S7)(V),V.constants.add("tiltThreshold","float",.7),V.code.add((0,C.H)(a||(a=(0,P.A)(["vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}"]))))):V.code.add((0,C.H)(s||(s=(0,P.A)(["vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}"]))));const G=F?"vec3":"vec2";return V.code.add((0,C.H)(o||(o=(0,P.A)(["\n      "," normalizedSegment("," pos, "," prev) {\n        "," segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ",";\n      }\n\n      "," displace("," pos, "," prev, float displacementLen) {\n        "," segment = normalizedSegment(pos, prev);\n\n        "," displacementDirU = perpendicular(segment);\n        "," displacementDirV = segment;\n\n        ","\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    "])),G,G,G,G,F?"vec3(0.0, 0.0, 0.0)":"vec2(0.0, 0.0)",G,G,G,G,G,G,B===b.kJ.Tip?"pos -= 0.5 * displacementLen * displacementDirV;":"")),r===b.lM.Screen&&(V.uniforms.add(new D.F("inverseProjectionMatrix",e=>{let{camera:t}=e;return t.inverseProjectionMatrix})),V.code.add((0,C.H)(c||(c=(0,P.A)(["vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}"])))),V.code.add((0,C.H)(l||(l=(0,P.A)(["bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}"])))),V.uniforms.add(new z.U("perScreenPixelRatio",e=>{let{camera:t}=e;return t.perScreenPixelRatio})),V.code.add((0,C.H)(p||(p=(0,P.A)(["\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ",";\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  "])),(0,C.If)(e.hasCap,"if(prev.z > posLeft.z) {\n                vec2 diff = posLeft.xy - posRight.xy;\n                planeOrigin.xy += perpendicular(diff) / 2.0;\n             }")))),(0,R.Nz)(V),V.main.add((0,C.H)(d||(d=(0,P.A)(["\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      float lineWidth = getLineWidth();\n      float screenMarkerSize = getScreenMarkerSize();\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(position + previousDelta.xyz * previousDelta.w, 1.0);\n      clip(pos, prev);\n\n      ","\n      forwardViewPosDepth(pos.xyz);\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ","\n      ","\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }"])),F?(0,C.H)(h||(h=(0,P.A)(["","\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\n            vec4 displacedPosScreen = projectAndScale(pos);"])),(0,C.If)(e.hideOnShortSegments,(0,C.H)(v||(v=(0,P.A)(["\n                if (areWorldMarkersHidden(pos, prev)) {\n                  // Project out of clip space\n                  gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                  return;\n                }"]))))):(0,C.H)(u||(u=(0,P.A)(["\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ",""])),(0,C.If)(r===b.lM.Screen,(0,C.H)(m||(m=(0,P.A)(["\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);"]))))),(0,C.If)(!F,"vUV *= displacedPosScreen.w;"),(0,C.If)(H,"vLineWidth = lineWidth;"))),j.include(A.HQ,e),t.include(M.z,e),j.include(w.a),j.uniforms.add(new x.E("intrinsicColor",e=>{let{color:t}=e;return t}),new k.N("tex",e=>{let{markerTexture:t}=e;return t})).constants.add("texelSize","float",1/g.vO).code.add((0,C.H)(f||(f=(0,P.A)(["float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgbaTofloat(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}"])))),H&&j.constants.add("relativeMarkerSize","float",g.Cz/g.vO).constants.add("relativeTipLineWidth","float",g.DZ).code.add((0,C.H)(S||(S=(0,P.A)(["\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ","\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  "])),(0,C.If)(F,"halfTipLineWidth *= fwidth(samplePos.y);"))),t.include(E.Q,e),j.main.add((0,C.H)(T||(T=(0,P.A)(["\n    discardBySlice(vpos);\n    discardByTerrainDepth();\n\n    vec4 finalColor = intrinsicColor * vColor;\n\n    // Cancel out perspective correct interpolation if in screen space or draped\n    vec2 samplePos = vUV ",";\n    finalColor.a *= ",";\n    outputColorHighlightOID(finalColor, vpos, finalColor.rgb);"])),(0,C.If)(!F,"* gl_FragCoord.w"),H?"max(markerAlpha(samplePos), tipAlpha(samplePos))":"markerAlpha(samplePos)")),t}const H=Object.freeze(Object.defineProperty({__proto__:null,build:B},Symbol.toStringTag,{value:"Module"}))}}]);
//# sourceMappingURL=41009.2fdd5ed8.chunk.js.map